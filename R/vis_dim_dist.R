#' Visualize the distribution difference of samples after dimension reduction analysis
#'
#' @param ids molecular identifiers (>=3)
#' @param data_type molecular types, refer to query_pancan_value() function
#' @param return.data whether to reture the raw meta/matrix data (list) instead of plot
#' @param DR_method the dimension reduction method
#' @param palette the color setting of RColorBrewer
#' @param add_margin the marginal plot (NULL, "density", "boxplot")
#' @param ... parameters refer to query_tcga_group() function
#' @param group_levels group levels setting
#' @param opt_pancan specify one dataset for some molercular profiles

#' @return a ggplot object or rawdata list
#' @export
#'
#' @examples
#' \dontrun{
#' vis_dim_dist(
#'   ids = c("TP53", "KRAS", "PTEN", "MDM2", "CDKN1A"),
#'   cancer = "BRCA",
#'   group = "Gender",
#'   group_levels = NULL
#' )
#' 
#' 
#' vis_dim_dist(
#'   ids = c("TP53", "KRAS", "PTEN", "MDM2", "CDKN1A"),
#'   cancer = "BRCA",
#'   group = "Code",
#'   merge_by = list("Tumor"=c("TP","TM"),"Normal"=c("NT")),
#'   group_levels = c("Normal","Tumor"),
#'   add_margin = "boxplot"
#' )
#' 
#' vis_dim_dist(
#'   ids = c("TP53", "KRAS", "PTEN", "MDM2", "CDKN1A"),
#'   cancer = c("LIHC","BRCA"),
#'   group = "Cancer",
#'   group_levels = c("BRCA","LIHC"),
#'   filter_by = list(c("Code",c("TP"),"+")),
#'   add_margin = "density"
#' )
#' }
#' 
vis_dim_dist <- function(ids = c("TP53", "KRAS", "PTEN", "MDM2", "CDKN1A"),
                          data_type = "mRNA", 
                          return.data = FALSE,
                          DR_method = c("PCA", "UMAP", "tSNE"),
                          palette = "Set1", add_margin = NULL,
                          group_levels = NULL, 
                          opt_pancan = .opt_pancan,
                          ...) {
  # Mode <- match.arg(Mode)
  DR_method <- match.arg(DR_method)
  
  if (length(ids) < 3) {
    stop("The number of valid ids is less than three. Please inspect the input ids and data_type(?query_pancan_value)")
  }
  
  exp_raw <- purrr::map(ids, function(x) {
    # x = ids[1]
    data <- query_pancan_value(x, data_type = data_type, opt_pancan=opt_pancan)
    data <- data[[1]]
    data <- dplyr::tibble(sample = names(data), y = as.numeric(data))
    colnames(data)[2] <- x
    data
  }) %>% purrr::reduce(dplyr::full_join, by = "sample")
  
  
  meta_raw = query_tcga_group(...)$data
  meta_data = meta_raw %>% dplyr::filter(.data$Sample %in% exp_raw$sample)
  group = tail(colnames(meta_data),1)
  if (!is.factor(meta_data[,group,drop=TRUE])) {
    if(is.null(group_levels)){
      group_levels = unique(meta_data[,group,drop=TRUE])
    }
    meta_data = meta_data[meta_data[,group,drop=TRUE] %in% group_levels,]
    meta_data[,group] = factor(meta_data[,group,drop=TRUE], levels=group_levels)  
  }

  
  exp_data = exp_raw[match(meta_data$Sample, exp_raw$sample), ]
  ids_NAN <- colnames(exp_data[, -1])[apply(exp_data[, -1], 2, function(x) all(is.na(x)))]
  ids_SD0 <- colnames(exp_data[, -1])[apply(exp_data[, -1], 2, function(x) stats::sd(x) == 0)] %>% na.omit()
  ids_OK <- setdiff(ids, c(ids_NAN, ids_SD0))
  # message(paste0((length(ids_OK)/length(ids))*100, "%"), " of input ids were obtained")
  exp_data <- exp_data[, which(!colnames(exp_data) %in% c(ids_NAN, ids_SD0))]


  if (return.data) {
    return(list(exp=exp_data, meta=meta_data))
  }

  
  # identical(exp_data$sample, meta_data$Sample)
  
  if (DR_method == "PCA") {
    pca_obj <- prcomp(exp_data[, ids_OK], center = TRUE, scale = TRUE)
    res_dims <- pca_obj$x[, 1:2] %>%
      as.data.frame() %>%
      dplyr::rename("PC_1" = "PC1", "PC_2" = "PC2")
  } else if (DR_method == "tSNE") {
    if (!requireNamespace("Rtsne", quietly = TRUE)) {
      stop(
        "Package \"Rtsne\" must be installed to use this method.",
        call. = FALSE
      )
    }
    set.seed(123)
    tsne_obj <- Rtsne::Rtsne(exp_data[, ids_OK])
    res_dims <- tsne_obj$Y %>%
      as.data.frame() %>%
      dplyr::rename("tSNE_1" = "V1", "tSNE_2" = "V2")
  } else if (DR_method == "UMAP") {
    if (!requireNamespace("umap", quietly = TRUE)) {
      stop(
        "Package \"umap\" must be installed to use this method.",
        call. = FALSE
      )
    }
    umap_obj <- umap::umap(exp_data[, ids_OK])
    res_dims <- umap_obj$layout %>%
      as.data.frame() %>%
      dplyr::rename("UMAP_1" = "V1", "UMAP_2" = "V2")
  }
  
  res_dims <- cbind(res_dims, meta_data)
  
  
  ## Step5: ggplot scatter plot
  if (length(group_levels) > 6) {
    colors <- grDevices::hcl(
      h = seq(15, 375, length = length(group_levels) + 1),
      l = 65, c = 100
    )[seq(length(group_levels))]
    shapes <- rep(16, length(group_levels))
  } else {
    colors <- RColorBrewer::brewer.pal(n = 6, name = palette)[seq(group_levels)]
    shapes <- c(15:20)[seq(group_levels)]
  }
  
  
  p <- ggplot2::ggplot(res_dims, aes_string(colnames(res_dims)[1], colnames(res_dims)[2], color = group, shape = group)) +
    ggplot2::geom_point() +
    ggplot2::stat_ellipse() +
    ggplot2::theme_classic(base_size = 20) +
    ggplot2::guides(
      color = guide_legend(title = NULL),
      shape = guide_legend(title = NULL)
    ) +
    ggplot2::theme(
      legend.background = element_blank(),
      legend.position = c(0, 0),
      legend.justification = c(0, 0)
    ) +
    ggplot2::scale_color_manual(values = colors) +
    ggplot2::scale_shape_manual(values = shapes)
  
  if (!is.null(add_margin)) {
    geom_type <- switch(add_margin,
                        "density" = geom_density,
                        "boxplot" = geom_boxplot,
                        stop("Please choose one of density/boxplot marginal type")
    )
    
    p_right <- cowplot::axis_canvas(p, axis = "x") +
      geom_type(
        data = p$data, aes_string(x = colnames(p$data)[1], fill = group),
        alpha = 0.8, linewidth = 0.3
      ) +
      ggplot2::scale_fill_manual(values = colors)
    p_top <- cowplot::axis_canvas(p, axis = "y", coord_flip = TRUE) +
      geom_type(
        data = p$data, aes_string(x = colnames(p$data)[2], fill = group),
        alpha = 0.8, linewidth = 0.3
      ) +
      coord_flip() +
      ggplot2::scale_fill_manual(values = colors)
    p_tmp <- p %>%
      cowplot::insert_xaxis_grob(p_right, grid::unit(.2, "null"), position = "top") %>%
      cowplot::insert_yaxis_grob(p_top, grid::unit(.2, "null"), position = "right")
    p_tmp2 <- cowplot::ggdraw(p_tmp)
    p_tmp2$data <- p$data
    p <- p_tmp2
  }
  return(p)
}